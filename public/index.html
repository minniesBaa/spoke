<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Google+Sans+Code:ital,wght@0,300..800;1,300..800&family=Mozilla+Text:wght@200..700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin-top: calc((100vh - 60vmin) / 2 - 60px);
            background-color: #555;
            color: #eee;
        }
        #b {
            overflow: hidden;
            position: relative;
            display: flex;
            width: 60vmin;
            height: 72vmin;
            border-radius: 5%;
            background-color: #434343;
        }
        #body {
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .tile {
            text-align: center;
            font-family: "Google Sans Code", monospace;
            font-optical-sizing: auto;
            font-weight: 550;
            font-style: normal;
            font-size: 7vmin;
            position: absolute;
            width: 10vmin;
            height: 10vmin;
            border: 2px solid #333;
            top: 0%;
            left: 0%;
            border-radius: 25%;
        }
    </style>
</head>
<body>
    <div id="body">
    <div id="b">
    </div>
    <div> 
        <ul id="aw">
        </ul>
    </div>
    </div>
    <script>
        let words = ['quest', 'speed', 'knelt', 'break'];
        let wordBuffer = "";
        let l1;
        let l2;
        let l3;
        let l4;
        let l5;
        let typing;
        let blocksList = []; // to be used by block cleanup
        let usedSquares = []; // for finding what squares have green tiles in them
        class Block {
            constructor(x, y, yo, xo, text, color){
                this._setProps(x, y, yo, xo, text, color);
                const blockParent = document.getElementById("b");
                this.el = document.createElement("div");
                this.el.className = "tile"
                this.el.innerHTML = text
                blockParent.appendChild(this.el);
                this._updatePosition();
                this.yvel = -0.5;
                this.ge = false;
                this.lock = null;
                blocksList.push(this);
                this.color = color;
                this.dropColor = color;
            }
            toggleGravity(){
                this.ge = !this.ge;
            }
            goto(x, y, yo, xo, color){
                this._setProps(x, y, yo, xo, color);
                this._updatePosition();
            }
            gravityTick(){
                if (!this.ge){return;}
                if (this.y > 30) {
                    this.el.remove();
                }
                this.yvel += 0.01
                
                if (this.yo >= vminToPx(11.5)){
                    this.y++;
                    this.yo -= vminToPx(11.5)
                }
                if (this.y == this.lock){
                    this.toggleGravity();
                    this.goto(this.x, this.y, 0, 0, this.dropColor);
                }
                this.goto(this.x, this.y, this.yo + this.yvel, this.xo, this.color);
            }
            setText(text){
                if(text){
                    this.text = text;
                    this.el.innerHTML = text;
                } else {
                    this.text = "";
                    this.el.innerHTML = "";
                }
            }
            _setProps(x, y, yo, xo, color){
                this.x = x;
                this.y = y;
                this.yo = yo;
                this.xo = xo;
                this.color = color;
            }
            _updatePosition(){
                this.el.style.left = `calc(${10.5 * this.x - 10 + this.x}vmin + ${this.xo}px)`;
                this.el.style.top = `calc(${10.5 * this.y - 10 + this.y}vmin + ${this.yo}px)`;
                this.el.style.backgroundColor = this.color;
            }
        }
        function vminToPx(vmin){
            return (vmin / 100) * Math.min(window.innerHeight, window.innerWidth);
        }
        function tick(){
            blocksList.forEach(i => {
                i.gravityTick();
            })
        }
        function dropTypingBlocks(){
            l1 = new Block(1, -1, 0, 0, "", "#4f4f4f")
            l2 = new Block(2, -2, 0, 0, "", "#4f4f4f")
            l3 = new Block(3, -3, 0, 0, "", "#4f4f4f")
            l4 = new Block(4, -4, 0, 0, "", "#4f4f4f")
            l5 = new Block(5, -5, 0, 0, "", "#4f4f4f")
            l1.toggleGravity();
            l2.toggleGravity();
            l3.toggleGravity();
            l4.toggleGravity();
            l5.toggleGravity();
            l1.lock = 1;
            l2.lock = 1;
            l3.lock = 1;
            l4.lock = 1;
            l5.lock = 1;
        }
        async function init(){
            const response = await fetch("puzzle.txt");
            words = await response.json();
            const patterns = [
                [1, 2],
                [3, 2],
                [5, 2],
                [2, 3],
                [3, 3],
                [4, 3],
                [1, 4],
                [2, 4],
                [3, 4],
                [4, 4],
                [5, 4],
                [2, 5],
                [3, 5],
                [4, 5],
                [1, 6],
                [3, 6],
                [5, 6]
            ]
            let j = 2;
            patterns.forEach(i => {
                j++;
                const currentTile = new Block(i[0], i[1] - j, 0, 0, "")
                currentTile.lock = i[1]
                currentTile.toggleGravity()
            })
            setInterval(tick, 5)
            setTimeout(() => {
                typing = true;
                dropTypingBlocks()
            }, 2500)
        }
        function captureKeyboardInput(event){
            if(!typing){
                return;
            }
            const allowedChars = "qwertyuiopasdfghjklzxcvbnm";
            const char = event.key.toLowerCase();
            if (allowedChars.includes(char) || char === "backspace" ){
                if (wordBuffer.length > 0 && char == "backspace"){
                    wordBuffer = wordBuffer.slice(0, -1);
                } else if (wordBuffer.length < 5 && char != "backspace"){
                    wordBuffer = wordBuffer.concat(char);
                }
            }
            // write buffer to screen
            l1.setText(wordBuffer[0]);
            l2.setText(wordBuffer[1]);
            l3.setText(wordBuffer[2]);
            l4.setText(wordBuffer[3]);
            l5.setText(wordBuffer[4]);

            if (char == "enter" && wordBuffer.length == 5){
                const aw = document.getElementById("aw");
                const wordForList = document.createElement("li");
                wordForList.innerHTML = wordBuffer;
                aw.appendChild(wordForList);
                wordBuffer = "";
                drop(l1);
                drop(l2);
                drop(l3);
                drop(l4);
                drop(l5);
                typing = false;
                setTimeout(() => {
                    typing = true;
                    dropTypingBlocks();
                }, 500)
            }
        }
        function drop(obj){
            obj.yvel = -1 - obj.x / 9;
            const dropData = calculateDropPosition(obj)
            obj.lock = dropData[0];
            obj.toggleGravity();
            console.log(obj);
            if(dropData[1] == "orange"){
                obj.dropColor = "#ad8907"
            } else if (dropData[1] == "green"){
                obj.dropColor = "#059019"
            }
        }
        function calculateDropPosition(obj){
            const orange = checkorangePos(obj);
            const green = checkgreenPos(obj);
            if (green === null && orange !== null) {
                return [orange, "orange"];
            }
            if (orange === null && green !== null) {
                usedSquares.push(`${obj.x}.${green}`);
                return [green, "green"];
            }
            if (orange === null && green === null){
                return [null, "none"]; 
            }
            if (orange < green){
                return [orange, "orange"];
            } else {
                usedSquares.push(`${obj.x}.${green}`);
                return [green, "green"];
            }
        }
        function checkgreenPos(obj){
            if(obj.x == 3){
                for (let i = 0; i < 5; i++){
                    if (words[1][i] === obj.text && !usedSquares.includes(`3.${i + 2}`)){
                        return i + 2
                    }
                }
                return null;
            }
            const xChart = [null,
                [2, 4, 6],
                [3, 4, 5],
                [2, 3, 4, 5, 6],
                [3, 4, 5],
                [2, 4, 6]
            ]
            const yPos = xChart[obj.x];
            let res = null;
            yPos.forEach((i) => {
                const char =  words[checkWord(obj.x, i) - 1][obj.x - 1]
                if (obj.text === char) {
                    if (!res && !usedSquares.includes(`${obj.x}.${i}`)){
                        console.log(`green set result ${i}`)
                        res = i;
                    }
                }
            })
            return res;
        }
        function checkorangePos(obj){
            if (obj.x == 3){
                return null;
            }
            const xChart = [null,
                [2, 4, 6],
                [3, 4, 5],
                [2, 3, 4, 5, 6],
                [3, 4, 5],
                [2, 4, 6]
            ]
            const yPos = xChart[obj.x];
            let res = null;
            yPos.forEach((i) => {
                const char =  words[checkWord(obj.x, i) - 1]
                console.log(char)
                if (char.includes(obj.text)) {
                    if (res == null && !usedSquares.includes(`${obj.x}.${i}`)){
                        console.log(`orange set result ${i}`)
                        res = i;
                    }
                }
            })
            return res;

        }
        function checkWord (x, y){
            const pos = [
                [1,0,2,0,3],
                [0,1,2,3,0],
                [4,4,4,4,4],
                [0,3,2,1,0],
                [3,0,2,0,1]
            ]
            const posX = x - 1;
            const posY = y - 2;
            const objWord = pos[posY][posX];
            return objWord;

        }
        document.addEventListener("keydown", captureKeyboardInput);
        document.addEventListener("DOMContentLoaded", init);

    </script>
</body>
</html>
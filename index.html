<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Google+Sans+Code:ital,wght@0,300..800;1,300..800&family=Mozilla+Text:wght@200..700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spoke Word Game</title>
    <style>
        #hidden-input {
            position: absolute;
            left: -9999px;
            top: -9999px;
            caret-color: transparent;
}
        body {
            font-family: "Mozilla Text";
            margin: 10px;
            background-color: #555;
            color: #eee;

        }
        #b {
            overflow: hidden;
            position: relative;
            display: flex;
            width: 60vmin;
            height: 72vmin;
            border-radius: 5%;
            background-color: #434343;
            box-shadow: 3px 3px 3px #222;
        }
        #body {
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            }
        .tile {

            text-align: center;
            font-family: "Google Sans Code", monospace;
            font-optical-sizing: auto;
            font-weight: 550;
            font-style: normal;
            font-size: 7vmin;
            position: absolute;
            width: 10vmin;
            height: 10vmin;
            border: 2px solid #333;
            top: 0%;
            left: 0%;
            border-radius: 25%;
        }
        #winoverlay{
            display: none;
            position: fixed;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
            justify-content: center;
            align-items: center;
            z-index: 100%;
            background-color: rgba(0, 0, 0, 0.2);
        }
        #wincontent{
            box-shadow: 3px 3px 3px #222;
            border-radius: 10px;
            padding: 20px;
            background-color: #333;
        }
        h1{
            margin: 5px;
        }
        button, textarea{
            background-color: #222;
            color: #eee;
        }
        textarea{
            width: 30vw;
            height: 30vw;
        }
        a{
            color: #eee;
        }
        #sidebar{
            height: 72vmin;
            overflow: auto;
        }
        img{
            width: 60vmin;
            padding-bottom: 5px;
        }
    </style>
    <link rel="icon" href="spokelogo.ico">
</head>
<body onclick="document.getElementById('hidden-input').focus()">
    <input id="hidden-input">
    <img src="spokebanner.png" alt="spoke logo banner" style="display: block;margin: auto;">
    <div id="body">
    <div id="b">
        
    </div>
    <div id="sidebar"> 
        <ul id="aw">
            <a href="howtoplay.html">How to <br>Play</a>
            <br><br>
            Guesses:
        </ul>
    </div>
    </div>
    <div id="winoverlay">
        <div id="wincontent">
            <button onclick="closePopup()">x</button>
            <h1>Puzzle Solved!</h1>
            <textarea name="sharesolve" id="share" readonly></textarea>
        </div>
    </div>
    <script>
        const mobileInput = document.getElementById('hidden-input')
        let dictionary = []
        let words = [];
        let wordBuffer = "";
        let hints = 0;
        let l1;
        let l2;
        let l3;
        let l4;
        let l5;
        let typing;
        let colorBuffer;
        let guessColors = [];
        let blocksList = []; // to be used by block cleanup
        let usedSquares = []; // for finding what squares have green tiles in them
        function closePopup(){
            const el = document.getElementById('winoverlay');
            el.style.display='none';
        }
        class Block {
            constructor(x, y, yo, xo, text, color){
                this._setProps(x, y, yo, xo, text, color);
                const blockParent = document.getElementById("b");
                this.el = document.createElement("div");
                this.el.className = "tile"
                this.el.innerHTML = text
                blockParent.appendChild(this.el);
                this._updatePosition();
                this.yvel = -0.5;
                this.ge = false;
                this.lock = null;
                blocksList.push(this);
                this.color = color;
                this.dropColor = color;
            }
            toggleGravity(){
                this.ge = !this.ge;
            }
            goto(x, y, yo, xo, color){
                this._setProps(x, y, yo, xo, color);
                this._updatePosition();
            }
            gravityTick(){
                if (!this.ge){return;}
                if (this.y > 30) {
                    this.el.remove();
                }
                this.yvel += 0.01
                
                if (this.yo >= vminToPx(11.5)){
                    this.y++;
                    this.yo -= vminToPx(11.5)
                }
                if (this.y == this.lock){
                    this.toggleGravity();
                    this.goto(this.x, this.y, 0, 0, this.dropColor);
                }
                this.goto(this.x, this.y, this.yo + this.yvel, this.xo, this.color);
            }
            setText(text){
                if(text){
                    this.text = text;
                    this.el.innerHTML = text;
                } else {
                    this.text = "";
                    this.el.innerHTML = "";
                }
            }
            _setProps(x, y, yo, xo, color){
                this.x = x;
                this.y = y;
                this.yo = yo;
                this.xo = xo;
                this.color = color;
            }
            _updatePosition(){
                this.el.style.left = `calc(${10.5 * this.x - 10 + this.x}vmin + ${this.xo}px)`;
                this.el.style.top = `calc(${10.5 * this.y - 10 + this.y}vmin + ${this.yo}px)`;
                this.el.style.backgroundColor = this.color;
            }
        }
        function vminToPx(vmin){
            return (vmin / 100) * Math.min(window.innerHeight, window.innerWidth);
        }
        function tick(){
            blocksList.forEach(i => {
                i.gravityTick();
            })
        }
        function dropTypingBlocks(){
            l1 = new Block(1, -1, 0, 0, "", "#4f4f4f")
            l2 = new Block(2, -2, 0, 0, "", "#4f4f4f")
            l3 = new Block(3, -3, 0, 0, "", "#4f4f4f")
            l4 = new Block(4, -4, 0, 0, "", "#4f4f4f")
            l5 = new Block(5, -5, 0, 0, "", "#4f4f4f")
            l1.toggleGravity();
            l2.toggleGravity();
            l3.toggleGravity();
            l4.toggleGravity();
            l5.toggleGravity();
            l1.lock = 1;
            l2.lock = 1;
            l3.lock = 1;
            l4.lock = 1;
            l5.lock = 1;
        }
        async function init(){
            const response = await fetch("puzzle.json");
            words = await response.json();
            const dict_res = await fetch("words.json");
            dictionary = await dict_res.json();
            const patterns = [
                [1, 2],
                [3, 2],
                [5, 2],
                [2, 3],
                [3, 3],
                [4, 3],
                [1, 4],
                [2, 4],
                [3, 4],
                [4, 4],
                [5, 4],
                [2, 5],
                [3, 5],
                [4, 5],
                [1, 6],
                [3, 6],
                [5, 6]
            ]
            let j = 2;
            patterns.forEach(i => {
                j++;
                const currentTile = new Block(i[0], i[1] - j, 0, 0, "")
                currentTile.lock = i[1]
                currentTile.toggleGravity()
            })
            setInterval(tick, 5)
            setTimeout(() => {
                typing = true;
                dropTypingBlocks()
            }, 2500)
        }
        async function checkDicionary(word) {
            try {
                const req = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (req.ok || req.status == 404){
                    return true
                } else {
                    return dictionary.includes(word);
                }
            } catch {
                return dictionary.includes(word);
            }
        }
        function captureKeyboardInput(event){
            if(!typing){
                return;
            }
            const allowedChars = "qwertyuiopasdfghjklzxcvbnm";
            const char = event.key.toLowerCase();
            if (allowedChars.includes(char) || char === "backspace" ){
                if (wordBuffer.length > 0 && char == "backspace"){
                    wordBuffer = wordBuffer.slice(0, -1);
                } else if (wordBuffer.length < 5 && char != "backspace"){
                    wordBuffer = wordBuffer.concat(char);
                }
            }
            // write buffer to screen
            l1.setText(wordBuffer[0]);
            l2.setText(wordBuffer[1]);
            l3.setText(wordBuffer[2]);
            l4.setText(wordBuffer[3]);
            l5.setText(wordBuffer[4]);

            if (char == "enter" && wordBuffer.length == 5 && checkDicionary()){
                const aw = document.getElementById("aw");
                const wordForList = document.createElement("li");
                wordForList.innerHTML = wordBuffer;
                aw.appendChild(wordForList);
                wordBuffer = "";
                colorBuffer = "";
                drop(l1);
                drop(l2);
                drop(l3);
                drop(l4);
                drop(l5);
                guessColors.push(colorBuffer);
                typing = false;
                setTimeout(() => {
                    typing = true;
                    dropTypingBlocks();
                }, 500)
                setTimeout(()=>{
                    if (usedSquares.length == 17){
                        usedSquares.push("");
                        const now = new Date();
                        const shareDisplay = `I finished the Spoke puzzle for ${now.getMonth() + 1}/${now.getDay()}/${now.getFullYear()} in ${guessColors.length} guesses with ${hints} hints!
Play it yourself at https://jwordgame012.web.app !
${guessColors.join("\n")}`
                        document.getElementById("share").innerHTML = shareDisplay;
                        document.getElementById("winoverlay").style.display="flex";
                    }
                },4000)
            }
        }
        function drop(obj){
            obj.yvel = -1 - obj.x / 9;
            const dropData = calculateDropPosition(obj)
            obj.lock = dropData[0];
            obj.toggleGravity();
            if(dropData[1] == "orange"){
                obj.dropColor = "#ad8907"
                colorBuffer = colorBuffer.concat("🟨")
            } else if (dropData[1] == "green"){
                obj.dropColor = "#059019"
                colorBuffer = colorBuffer.concat("🟩")
            } else {
                colorBuffer = colorBuffer.concat("⬛")
            }
        }
        function calculateDropPosition(obj){
            const orange = checkorangePos(obj);
            const green = checkgreenPos(obj);
            if (green === null && orange !== null) {
                return [orange, "orange"];
            }
            if (orange === null && green !== null) {
                usedSquares.push(`${obj.x}.${green}`);
                return [green, "green"];
            }
            if (orange === null && green === null){
                return [null, "none"]; 
            }
            if (orange < green){
                return [orange, "orange"];
            } else {
                usedSquares.push(`${obj.x}.${green}`);
                return [green, "green"];
            }
        }
        function checkgreenPos(obj){
            if(obj.x == 3){
                for (let i = 0; i < 5; i++){
                    if (words[1][i] === obj.text && !usedSquares.includes(`3.${i + 2}`)){
                        return i + 2
                    }
                }
                return null;
            }
            const xChart = [null,
                [2, 4, 6],
                [3, 4, 5],
                [2, 3, 4, 5, 6],
                [3, 4, 5],
                [2, 4, 6]
            ]
            const yPos = xChart[obj.x];
            let res = null;
            yPos.forEach((i) => {
                const char =  words[checkWord(obj.x, i) - 1][obj.x - 1]
                if (obj.text === char) {
                    if (!res && !usedSquares.includes(`${obj.x}.${i}`)){
                        res = i;
                    }
                }
            })
            return res;
        }
        function checkorangePos(obj){
            if (obj.x == 3){
                return null;
            }
            const xChart = [null,
                [2, 4, 6],
                [3, 4, 5],
                [2, 3, 4, 5, 6],
                [3, 4, 5],
                [2, 4, 6]
            ]
            const yPos = xChart[obj.x];
            let res = null;
            yPos.forEach((i) => {
                const char =  words[checkWord(obj.x, i) - 1]
                if (char.includes(obj.text)) {
                    if (res == null && !usedSquares.includes(`${obj.x}.${i}`)){
                        res = i;
                    }
                }
            })
            return res;

        }
        function checkWord (x, y){
            const pos = [
                [1,0,2,0,3],
                [0,1,2,3,0],
                [4,4,4,4,4],
                [0,3,2,1,0],
                [3,0,2,0,1]
            ]
            const posX = x - 1;
            const posY = y - 2;
            const objWord = pos[posY][posX];
            return objWord;

        }
        document.addEventListener("keydown", captureKeyboardInput);
        document.addEventListener("DOMContentLoaded", init);

    </script>
</body>
</html>